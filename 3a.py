#! /usr/bin/python

def hasha(message):
    i = 0
    digest = [0] * 16
    for l in message:
        if i == 0:
            digest[i] = ((129 * message[i]) ^ 0) % 256
        else:
            digest[i] = ((129 * message[i]) ^ message[i - 1]) % 256
        i = i + 1
    return digest
'''
dig[0] is the last 8 bits of result.
    result is xor of mult and 0 
        mult is prod of 129 and msg[0]

xor of dig[0] and 0 is last 8 digits of mult
    k

'''
def de_hasha(dig):
    #print(dig)
    i = 0
    msg = []
    #print("Message\tDeDigest")
    while i < 16:
        if i == 0:
            msg.append((0 ^ dig[i]) ^ 128)
        else:
            msg.append((msg[i-1] ^ dig[i]) ^ 128)
        if msg[0] % 2 == 0:
            if i % 4 == 2 or i % 4 == 0:
                msg[i] = msg[i] ^ 128
        else:
            if i % 4 == 1 or i % 4 ==3:
                msg[i] = msg[i] ^ 128

        #print(de_test[i], msg[i])
        #print(format(de_test[i],'#010b'), format(msg[i], '#010b'))

        i = i + 1
    return msg

test = []

for i in range(0,10):
    test.append([0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225])
    test.append(range(i, i + 16))

de_test = test[1]
#print(test[1])
#de_test = hasha(test[1])


def testing(t):
    ind = 0
    for i in t:
        #print("# m {count} = {dig}".format( count = ind, dig = i))
        #print("# d {count} = {dig}".format( count = ind, dig = hasha(i)))
        print(ind)
        print(i)
        #print(hasha(i))
        print(de_hasha(hasha(i)))
        ind = ind + 1
testing(test)

'''
message[-1] = 0
digest[i] = ((129 * message[i]) XOR message[i - 1]) % 256
From the puzzle readme
'''
'''
test.append([0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225])
test.append([0,2,4,9,16,25,36,49,64,81,100,121,144,169,196,225])
test.append([100,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225])
test.append([100,2,4,9,16,25,36,49,64,81,100,121,144,169,196,225])
test.append([200,2,4,9,16,25,36,49,64,81,100,121,144,169,196,225])

x = (k * n) ^ s % c

#Ergo c divides (k * n) ^ s - x

# right shift 8 times to get the quotient by 256 (c)
# all are 8 bit;
multiplying with 129 flips the left most bit

'''

# m 1 = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 1 = [0, 129, 5, 141, 25, 137, 61, 149, 113, 145, 53, 157, 233, 185, 109, 165]
# m 2 = [0, 2, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 2 = [0, 2, 6, 141, 25, 137, 61, 149, 113, 145, 53, 157, 233, 185, 109, 165]
# m 3 = [100, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 3 = [100, 229, 5, 141, 25, 137, 61, 149, 113, 145, 53, 157, 233, 185, 109, 165]
# m 4 = [100, 2, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 4 = [100, 102, 6, 141, 25, 137, 61, 149, 113, 145, 53, 157, 233, 185, 109, 165]
# m 5 = [200, 2, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 5 = [200, 202, 6, 141, 25, 137, 61, 149, 113, 145, 53, 157, 233, 185, 109, 165]

# m 1 = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 1 = [0, 129, 517, 1165, 2073, 3209, 4669, 6293, 8305, 10385, 12853, 15517, 18665, 21945, 25197, 29093]
# m 2 = [0, 2, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 2 = [0, 258, 518, 1165, 2073, 3209, 4669, 6293, 8305, 10385, 12853, 15517, 18665, 21945, 25197, 29093]
# m 3 = [100, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 3 = [12900, 229, 517, 1165, 2073, 3209, 4669, 6293, 8305, 10385, 12853, 15517, 18665, 21945, 25197, 29093]
# m 4 = [100, 2, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 4 = [12900, 358, 518, 1165, 2073, 3209, 4669, 6293, 8305, 10385, 12853, 15517, 18665, 21945, 25197, 29093]
# m 5 = [200, 2, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]
# d 5 = [25800, 458, 518, 1165, 2073, 3209, 4669, 6293, 8305, 10385, 12853, 15517, 18665, 21945, 25197, 29093]



